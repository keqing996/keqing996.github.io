import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as e}from"./app-Dw53g8wv.js";const l="/assets/Screenshot-BRQBl14x.jpg",t={};function h(p,s){return e(),a("div",null,s[0]||(s[0]=[n(`<p><a href="https://github.com/keqing996/AndroidCppWithAsm" target="_blank" rel="noopener noreferrer">AndroidAsm</a></p><p>首先创建一个Android Stuido的JNI工程。工程默认会生成一个C++文件，在Java侧调用native函数显示一个字符串。</p><p>Cpp这边生产的函数是静态绑定的，函数名字非常长，不太顺眼，先来改成动态绑定。先把冗长的函数改个名字。</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">JNIEXPORT jstring JNICALL </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">StringFromJNI</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(JNIEnv </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">env, jclass clazz)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::string hello { </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Hello World From JNI&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> };</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> env</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">NewStringUTF</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">hello</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">c_str</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来实现动态绑定。在Cpp文件中增加一个函数JniOnLoad，在这个函数中加载Java这边的native函数。</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">jint</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> JNI_OnLoad</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">JavaVM</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> vm</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> reserved</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    JNIEnv </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> env;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    vm</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GetEnv</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void**</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">env,JNI_VERSION_1_6);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    JNINativeMethod methods[] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            { </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;StringFromJNI&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;()Ljava/lang/String;&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)StringFromJNI },</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    env</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">RegisterNatives</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">env</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">FindClass</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;com/noemie/androidasm/MainActivity&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),methods,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> JNI_VERSION_1_6;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们要实现两个ARM64的汇编函数，一个函数返回一个数字，一个函数返回一个字符串。在StringFromJNI中组装两个汇编函数的返回值，再返回给Java，显示出来。</p><p>首先实现一个汇编函数直接返回一个数。在cpp目录下创建get_number.s。</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>.text</span></span>
<span class="line"><span>.global GetNumber</span></span>
<span class="line"><span>GetNumber:</span></span>
<span class="line"><span>    mov x0, #10</span></span>
<span class="line"><span>    ret</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现非常简单，声明了一个函数叫GetNumber，把常数10给寄存器x0，然后返回。在Arm汇编中，x0是放返回值的，类似x64中的rax。ret表示返回，在Arm32中是bx lr跳转指令，在Arm64是ret，这里需要注意。</p><p>接下来再实现一个汇编函数返回一个字符串，在cpp目录下创建get_hello_str.s。</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" data-title="assembly" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>.global GetHelloStr</span></span>
<span class="line"><span>.section .rodata</span></span>
<span class="line"><span>str:</span></span>
<span class="line"><span>    .asciz &quot;hello&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.text</span></span>
<span class="line"><span>GetHelloStr:</span></span>
<span class="line"><span>    adrp x0, str</span></span>
<span class="line"><span>    add x0, x0, :lo12:str</span></span>
<span class="line"><span>    ret</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先在rodata段中声明一个字符串hello，然后text段中声明一个函数叫GetHelloStr，汇编adrp和下面的add是arm64中很常见的写法，是通过偏移拿到一个指定地址。具体原理就不详述了，本文主要是走通流程，这里最后x0里塞的就是上面这个字符串的指针。然后返回。</p><p>接下来回到C++这边。首先extern声明这两个汇编函数，然后调用。</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">extern</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;C&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GetNumber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">extern</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;C&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> char*</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GetHelloStr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">JNIEXPORT jstring JNICALL </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">StringFromJNI</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(JNIEnv </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">env, jclass clazz)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::string hello </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::string { </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GetHelloStr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">to_string</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GetNumber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> env</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">NewStringUTF</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">hello</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">c_str</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样代码就写好了，接下里到Cmake里面加上两个汇编源文件。</p><div class="language-cmake line-numbers-mode" data-highlighter="shiki" data-ext="cmake" data-title="cmake" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># 声明启用汇编</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">enable_language</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ASM)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># 两个汇编文件加入源文件</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">add_library</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\${CMAKE_PROJECT_NAME}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SHARED</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        get_number.s</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        get_hello_str.s</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        native_lib.cpp)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，到gradle中设置ndk。因为我们直接写了汇编，这个汇编是Armv8的64位的指令，在Armv7下是编译不过的，因此我们需要设置这个库只编译Armv8版本的。</p><div class="language-kotlin line-numbers-mode" data-highlighter="shiki" data-ext="kotlin" data-title="kotlin" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">buildTypes</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    defaultConfig</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        ndk</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            abiFilters </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;arm64-v8a&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样build就可以了，在手机上应该可以顺利看到下图。</p><figure><img src="`+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',21)]))}const d=i(t,[["render",h],["__file","Arm64OnAndroid.html.vue"]]),A=JSON.parse('{"path":"/posts/Programming/Arm64OnAndroid.html","title":"Android上使用Arm64汇编","lang":"zh-CN","frontmatter":{"title":"Android上使用Arm64汇编","date":"2023-10-16T00:00:00.000Z","tags":["Cpp","Android"],"categories":["Programming"],"description":"AndroidAsm 首先创建一个Android Stuido的JNI工程。工程默认会生成一个C++文件，在Java侧调用native函数显示一个字符串。 Cpp这边生产的函数是静态绑定的，函数名字非常长，不太顺眼，先来改成动态绑定。先把冗长的函数改个名字。 接下来实现动态绑定。在Cpp文件中增加一个函数JniOnLoad，在这个函数中加载Java这边...","head":[["meta",{"property":"og:url","content":"https://keqing996.github.io/posts/Programming/Arm64OnAndroid.html"}],["meta",{"property":"og:site_name","content":"键盘缝的咖啡渍"}],["meta",{"property":"og:title","content":"Android上使用Arm64汇编"}],["meta",{"property":"og:description","content":"AndroidAsm 首先创建一个Android Stuido的JNI工程。工程默认会生成一个C++文件，在Java侧调用native函数显示一个字符串。 Cpp这边生产的函数是静态绑定的，函数名字非常长，不太顺眼，先来改成动态绑定。先把冗长的函数改个名字。 接下来实现动态绑定。在Cpp文件中增加一个函数JniOnLoad，在这个函数中加载Java这边..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-23T11:47:04.000Z"}],["meta",{"property":"article:author","content":"键盘缝的咖啡渍"}],["meta",{"property":"article:tag","content":"Cpp"}],["meta",{"property":"article:tag","content":"Android"}],["meta",{"property":"article:published_time","content":"2023-10-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-23T11:47:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Android上使用Arm64汇编\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-16T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-23T11:47:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"键盘缝的咖啡渍\\"}]}"]]},"headers":[],"git":{"createdTime":1726762060000,"updatedTime":1727092024000,"contributors":[{"name":"keqing996","email":"epigrf@outlook.com","commits":2}]},"readingTime":{"minutes":2.3,"words":691},"filePathRelative":"posts/Programming/Arm64OnAndroid.md","localizedDate":"2023年10月16日","autoDesc":true}');export{d as comp,A as data};
